<?xml version="1.0" encoding="UTF-8"?>
<!--
This Work is in the public domain and is provided on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
including, without limitation, any warranties or conditions of TITLE,
NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE.
You are solely responsible for determining the appropriateness of using
this Work and assume any risks associated with your use of this Work.

This Work includes contributions authored by David E. Jones, not as a
"work for hire", who hereby disclaims any copyright to the same.
-->
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified">
    <xs:include schemaLocation="common-types-1.2.xsd"/>
    <xs:include schemaLocation="xml-actions-1.2.xsd"/>
    <xs:include schemaLocation="xml-form-1.2.xsd"/>

    <!-- ================ Shared Elements ================ -->
    <xs:group name="section-elements">
        <xs:sequence>
            <xs:element ref="condition" minOccurs="0"/>
            <xs:element ref="actions" minOccurs="0"/>
            <xs:element ref="widgets"/>
            <xs:element ref="fail-widgets" minOccurs="0"/>
        </xs:sequence>
    </xs:group>
    <xs:group name="widget-elements">
        <xs:choice>
            <xs:element ref="AllWidgets"/>
            <xs:element ref="StandaloneFields"/>
            <!-- allow additional elements without validation to facilitate extension by adding only FTL macros -->
            <xs:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/>
        </xs:choice>
    </xs:group>

    <!-- ================ Screen - root element ================ -->
    <xs:element name="screen">
        <xs:annotation><xs:documentation>
            The screen is the basic unit of a user interface defines how data, logic, and visual elements fit together.

            Screen filenames should be camel-cased and start with an upper-case letter (whereas transitions should
            start with a lower-case letter).
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="macro-template" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="web-settings" minOccurs="0"/>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These are the parameters the screen expects or allows to be passed in, and where the calling
                        screen can get them from by default (usually just default to the same from, but can be a
                        static value for default or whatever).

                        Individual transition-response and other elements can override where the parameter comes from
                        with their own parameter sub-elements.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="always-actions" minOccurs="0"/>
                <xs:element ref="transition" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="subscreens" minOccurs="0"/>
                <xs:element ref="pre-actions" minOccurs="0"/>
                <xs:group ref="section-elements"/>
            </xs:sequence>
            <xs:attribute name="standalone" type="boolean" default="false">
                <xs:annotation><xs:documentation>
                    If set to true this screen will be rendered without rendering any parent screens. It can still be
                    referred to as a subscreen of its parent, but when rendered the parent will not run, the rendering
                    will start at this screen. Any non-standalone children will still be treated as normal subscreens.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="default-menu-title" type="xs:string"/>
            <xs:attribute name="default-menu-index" type="xs:positiveInteger"/>
            <xs:attribute name="default-menu-include" type="boolean" default="true">
                <xs:annotation><xs:documentation>
                    Set this to false to not automatically appear in the parent's subscreens menu based on the directory 
                    it is in. If true this screen will automatically be included in the parent's subscreens menu.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="require-authentication" default="true">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:enumeration value="true"/>
                        <xs:enumeration value="false"/>
                        <xs:enumeration value="anonymous-all"/>
                        <xs:enumeration value="anonymous-view"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            <!-- TABLED, not to be part of 1.0: <xs:attribute name="require-certificate" default="false" type="boolean"/> -->
            <xs:attribute name="begin-transaction" type="boolean" default="false">
                <xs:annotation><xs:documentation>
                    Begin a transaction for the screen render if there is not one already in place.
                    Most screens don't need this, but it is useful for greater data consistency in certain cases.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="include-child-content" type="boolean" default="false">
                <xs:annotation><xs:documentation>
                    False by default, meaning that child content is sent to the client as they are and nothing else with
                    it. If true then the child content is included in this screen as if it were a subscreen.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="screen-theme-type-enum-id" type="xs:string" default="STT_INTERNAL"/>
            <xs:attribute name="track-artifact-hit" type="boolean" default="true">
                <xs:annotation><xs:documentation>If set to false no ArtifactHit or ArtifactHitBin data will be kept for
                    this screen and for any content or transitions under the screen.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="login-path" type="xs:string" default="/Login">
                <xs:annotation><xs:documentation>If specified will be used as the login screen path for this screen and
                    any subscreens, otherwise defaults to "/Login".</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="allow-extra-path" type="boolean" default="false">
                <xs:annotation><xs:documentation>If set to true arbitrary path follow this screen's path is allowed.
                    Default is false and an exception will be thrown if there is extra path that does not match a
                    subscreen, a transition, or content below the screen.</xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="macro-template">
        <xs:annotation><xs:documentation>
            A location here will override the settings in the moqui-conf.screen-facade.screen-text-output, but will be
            overridden by a value set with the ScreenRender.macroTemplate() method.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:attribute name="type" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    Can be anything. Default supported values include: text, html, xsl-fo, xml, and csv.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="location" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="web-settings">
        <xs:complexType>
            <xs:attribute name="allow-web-request" default="true" type="boolean"/>
            <xs:attribute name="require-encryption" default="true" type="boolean"/>
            <xs:attribute name="mime-type" type="xs:string" default="text/html"/>
            <xs:attribute name="character-encoding" type="xs:string" default="UTF-8"/>
            <!-- TABLED, not to be part of 1.0: <xs:attribute name="http-no-cache" default="false" type="boolean"/> -->
            <!-- NOTE: Right now we send some cache headers, could add config for cache headers for screen,
                 static screen content, template screen content -->
        </xs:complexType>
    </xs:element>
    <xs:element name="always-actions">
        <xs:annotation><xs:documentation>These actions always run when this screen appears in a screen path, including
            both screen rendering and transition running. One difference between this and the pre-actions element is
            that this runs before transitions are processed while pre-actions do not. The always-actions also run for
            all screens in a path while the pre-actions only run for screens that will be rendered.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="pre-actions">
        <xs:annotation><xs:documentation>These actions run before any of the screens (this screen or any parent screens)
            are rendered, allowing you to set parameters used by parent screens or other general reasons.</xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:group minOccurs="0" maxOccurs="unbounded" ref="AllOperations"/>
        </xs:complexType>
    </xs:element>


    <!-- ================ Transition ================ -->
    <xs:element name="transition">
        <xs:annotation><xs:documentation>
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="path-parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These are additional path elements after the transition's path element. The values will be added
                        to the web parameters based on the order of these path-elements.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="condition" minOccurs="0">
                    <xs:annotation><xs:documentation>
                        This condition is run wherever this transition is referenced in the screen to see if the
                        transition is available (otherwise the button/link/etc is disabled).
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:choice minOccurs="0">
                    <xs:element ref="service-call">
                        <xs:annotation><xs:documentation>
                            In most cases the best way to handle input for a transition is with a single service. To do
                            that use this element instead of an actions element.

                            This will automatically have an in-map=true. To get the same effect inside the actions
                            element just use in-map=true.
                        </xs:documentation></xs:annotation>
                    </xs:element>
                    <xs:element ref="actions">
                        <xs:annotation><xs:documentation>
                            When this transition is followed these actions are run.

                            After the actions are run it goes to the url that this transition goes to (through
                            client-side redirect, dynamic update of a screen area, etc).
                        </xs:documentation></xs:annotation>
                    </xs:element>
                </xs:choice>
                <xs:element ref="conditional-response" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        If there are multiple transition-response sub-elements the first one whose condition evaluates
                        to true will be the one used. If no conditional responses match, the default-response will be
                        used.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="default-response">
                    <xs:annotation><xs:documentation>
                        This response must always be defined and is the response that will be used if there is no error
                        in the actions, and if none of the conditions in conditional responses evaluate to true.
                    </xs:documentation></xs:annotation>
                </xs:element>
                <xs:element ref="error-response" minOccurs="0">
                    <xs:annotation><xs:documentation>
                        If there is an error in evaluating the actions on this transition then the error-response will
                        be used and the transition-response element(s) will be ignored.

                        If there are actions and there is no error-response defined then the default error response
                        will be used.
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attribute name="name" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    Transition names should be camel-cased and start with an lower-case letter (whereas screen filenames
                    and subscreens-item names start with a upper-case letter).

                    The transition name is used in link and other elements in place of URLs when going to another
                    screen within this application. The transition name will appear briefly as the URL before the
                    redirect is done for the transition response.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="method" default="any">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:enumeration value="any"/>
                        <xs:enumeration value="get"/>
                        <xs:enumeration value="put"/>
                        <xs:enumeration value="post"/>
                        <xs:enumeration value="delete"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="path-parameter">
        <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="conditional-response">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="condition" minOccurs="0"/>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These parameters will be used when redirecting to the url or other activating of the target
                        screen.

                        Each screen has a list of expected parameters so this is only necessary when you need to
                        override where the parameter value comes from (default defined in the parameter tag under the
                        screen).
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.response"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="default-response">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These parameters will be used when redirecting to the url or other activating of the target
                        screen.

                        Each screen has a list of expected parameters so this is only necessary when you need to
                        override where the parameter value comes from (default defined in the parameter tag under the
                        screen).
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.response"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="error-response">
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="parameter" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation><xs:documentation>
                        These parameters will be used when redirecting to the url or other activating of the target
                        screen.

                        Each screen has a list of expected parameters so this is only necessary when you need to
                        override where the parameter value comes from (default defined in the parameter tag under the
                        screen).
                    </xs:documentation></xs:annotation>
                </xs:element>
            </xs:sequence>
            <xs:attributeGroup ref="attlist.response"/>
        </xs:complexType>
    </xs:element>
    <xs:attributeGroup name="attlist.response">
        <xs:attribute name="type" default="url">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="none"/>
                    <xs:enumeration value="screen-last">
                        <xs:annotation><xs:documentation>
                            Will use the screen from the last request unless there is a saved from some previous
                            request (using the save-last-screen attribute, done automatically for login).

                            If no last screen is found the value in the url will be used, and if nothing there will go
                            to the default screen (just to root with whatever defaults are setup for each subscreen).
                        </xs:documentation></xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="screen-last-noparam"/>
                    <xs:enumeration value="url"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="url" type="xs:string">
            <xs:annotation><xs:documentation>
                The URL to follow in response, based on the url-type. The default url-type is "screen-path" which means
                the value here is a path from the current screen to the desired screen (or transition).

                You can use "." to represent the current screen, and ".." to represent the parent screen on the runtime
                screen path. The ".." can be used multiple times, such as "../.." to get to the parent screen of the
                parent screen (the grand-parent screen).

                If the screen-path type url starts with a "/" it will be relative to the root screen instead of relative
                to the current screen.

                If the url-type is "plain" then this can be any valid URL (relative on current server or absolute).
            </xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="url-type" default="screen-path">
            <xs:simpleType>
                <xs:restriction base="xs:token">
                    <xs:enumeration value="screen-path">
                        <xs:annotation><xs:documentation>URI to another screen, either relative or from server root.
                            See documentation on url attribute for more details.</xs:documentation></xs:annotation>
                    </xs:enumeration>
                    <xs:enumeration value="plain"/>
                </xs:restriction>
            </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="parameter-map" type="xs:string"/>
        <!-- deferred for future version, pending finding a good reason that it is needed:
        <xs:attribute name="save-last-screen" default="false" type="boolean">
            <xs:annotation><xs:documentation>
                Saves the last (previous) screen's path and parameters for future use, generally with the screen-last type of
                response.
            </xs:documentation></xs:annotation>
        </xs:attribute> -->
        <xs:attribute name="save-current-screen" default="false" type="boolean">
            <xs:annotation><xs:documentation>Save the current screen's path and parameters for future use, generally
                with the screen-last type of response.</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="save-parameters" default="false" type="boolean">
            <xs:annotation><xs:documentation>Save the current parameters (and request attributes) before doing a
                redirect so that the screen rendered after the redirect renders in a context similar to the original
                request to the transition.</xs:documentation></xs:annotation>
        </xs:attribute>
    </xs:attributeGroup>

    <!-- ================ Subscreens ================ -->
    <xs:element name="subscreens">
        <xs:annotation><xs:documentation>
            Declare subscreens for this screen. One subscreen at a time is active, based on the "screen path" used to
            access this screen. The parent screen (this screen) will be the current element in the screen path and the
            next screen path element will be the name of the subscreen of this screen to use.

            If there is no additional element in the screen path or the next element is not a valid subscreen-item.name
            then the default-item will be the active subscreen. 

            There are three ways to add subscreens to a screen:

            1. for screens within a single application:
               by directory structure: create a directory in the directory where the parent screen is named the same as
               the parent screen's filename and put XML Screen files in that directory (name=filename up to .xml,
               title=screen.default-title, location=parent screen minus filename plus directory and filename for
               subscreen)
            2. for including screens that are part of another application, or shared and not in any application:
               subscreens-item elements below the screen -> subscreens element (this element)
            3. for adding screens, removing screens, or changing order and title of screens to an existing application:
               a record in the moqui.screen.SubscreensItem entity

            There are two visual elements (widgets) that come from the subscreens, a menu and the active subscreen.
            Those are included with the widgets using the "subscreens-menu" and "subscreens-active" elements, or the
            "subscreens-panel" element.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="conditional-default" minOccurs="0" maxOccurs="unbounded"/>
                <xs:element ref="subscreens-item" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="default-item" type="xs:string">
                <xs:annotation><xs:documentation>
                    The name of the default subscreen-item. Used when then screen-path ends on this screen so we
                    know which subscreen-item to activate.

                    If empty the first subscreen-item will be the default.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="always-use-full-path" type="boolean" default="false"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="conditional-default">
        <xs:complexType>
            <xs:attribute name="condition" type="xs:string" use="required">
                <xs:annotation><xs:documentation>Groovy condition expression (evaluates to a boolean) used to determine
                    if the specified subscreens item is the one to use by default instead of the on specified in the
                    subscreens.@default-item attribute.</xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="item" type="xs:string" use="required">
                <xs:annotation><xs:documentation>The subscreens item to make the default.</xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-item">
        <xs:annotation><xs:documentation>
            One way to add a subscreen. This is most commonly used to refer to a subscreen that is located in another
            application, another part of this application, that is not in any application and is meant to be shared,
            or is in a different type of location than the parent screen.

            One subscreens-item is active at a time, meaning that screen is shown and the tab/etc for that screen is
            highlighted.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:attribute name="name" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    The name of the subscreens item for use in the screen path. The screen path element following the
                    one for the parent screen of the item will match on this name.

                    Subscreen Item names should be camel-cased and start with a upper-case letter (just like screen
                    filenames start with a upper-case letter).
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="location" type="xs:string">
                <xs:annotation><xs:documentation>
                    Subscreen location can include various prefixes to support including from a file, http, component,
                    or a content repository.

                    If empty defaults to the value of the name attribute under the current screen (in the directory
                    with the same name as the current screen), and can be a screen or sub-content.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="menu-title" type="xs:string"/>
            <xs:attribute name="menu-index" type="xs:positiveInteger">
                <xs:annotation><xs:documentation>
                    If specified this item will be inserted in existing list of subscreens at this index (1-based).
                    If empty this item will be added to the end of the list (after the directory load, before the
                    entity load).
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="menu-include" type="boolean" default="true"/>
            <xs:attribute name="disable-when" type="xs:positiveInteger">
                <xs:annotation><xs:documentation>
                    This condition is run the subscreens menu is rendered to see if the item is available
                    (otherwise the button/link/etc is disabled).
                </xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-menu" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="type" default="tab">
                <xs:simpleType><xs:restriction base="xs:token">
                    <xs:enumeration value="tab"/>
                    <xs:enumeration value="popup"/>
                    <xs:enumeration value="popup-tree"/>
                </xs:restriction></xs:simpleType>
            </xs:attribute>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="title" type="xs:string"/>
            <xs:attribute name="width" type="xs:string" default="200px"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-active" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="id" type="xs:string" use="optional"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="subscreens-panel" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="type" default="tab">
                <xs:simpleType><xs:restriction base="xs:token">
                    <xs:enumeration value="tab"/>
                    <xs:enumeration value="popup"/>
                    <!-- TABLED, not to be part of 1.0: <xs:enumeration value="stack"/> -->
                    <!-- TABLED, not to be part of 1.0: <xs:enumeration value="wizard"/> -->
                </xs:restriction></xs:simpleType>
            </xs:attribute>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="title" type="xs:string"/>
            <xs:attribute name="menu-width" type="xs:string" default="200px"/>
            <xs:attribute name="dynamic" type="boolean" default="false"/>
        </xs:complexType>
    </xs:element>

    <!-- ================ Sections ================ -->
    <xs:element name="section" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:group ref="section-elements"/>
            <xs:attribute name="name" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    A name for the section, used for reference within the screen.
                    Must be specified and must be unique within the screen.
                </xs:documentation></xs:annotation>
            </xs:attribute>
        </xs:complexType>
    </xs:element>
    <xs:element name="section-iterate" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:group ref="section-elements"/>
            <xs:attribute name="name" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    A name for the section, used for external reference within the screen.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="list" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    The name of the field that contains the list to iterate over.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="entry" type="xs:string" use="required">
                <xs:annotation><xs:documentation>
                    The name of the field that will contain each entry as we iterate through the list.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="key" type="xs:string">
                <xs:annotation><xs:documentation>
                    If list points to a Map or List of MapEntry the key will be put where this refers to, the value
                    where the entry attribute refers to.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="paginate" type="xs:string" default="false">
                <!-- TODO handle paginate* in ScreenSection.groovy -->
                <xs:annotation><xs:documentation>
                    Indicate if this section is paginated or not, false by default.
                </xs:documentation></xs:annotation>
            </xs:attribute>
            <xs:attribute name="paginate-size" type="xs:string"/>
        </xs:complexType>
    </xs:element>

    <xs:element name="widgets">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="fail-widgets">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>

    <!-- ================ Containers ================ -->
    <xs:element name="container" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attribute name="id" type="xs:string"/>
            <xs:attribute name="style" type="xs:string"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="container-panel" substitutionGroup="AllWidgets">
        <xs:annotation><xs:documentation>
            This panel can have up to five areas: header, left, center, right, footer. Only the center area is required.
            This can be re-used within the different areas as well, usually just the center area but could be used to
            split up even the header and footer.

            If there is an id for the outer container, and each area will have an automatic id as well (with a suffix
            of: _header, _left, _center, _right, _footer).
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:sequence>
                <xs:element ref="panel-header" minOccurs="0"/>
                <xs:element ref="panel-left" minOccurs="0"/>
                <xs:element ref="panel-center"/>
                <xs:element ref="panel-right" minOccurs="0"/>
                <xs:element ref="panel-footer" minOccurs="0"/>
            </xs:sequence>
            <xs:attribute name="id" type="xs:string"/>
            <!-- not for 1.0, should use CSS styles, may add later if determined to be a good thing:
            <xs:attribute name="area-size-unit" default="px">
                <xs:simpleType>
                    <xs:restriction base="xs:token">
                        <xs:enumeration value="px"/>
                        <xs:enumeration value="em"/>
                    </xs:restriction>
                </xs:simpleType>
            </xs:attribute>
            -->
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-header">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-left">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <!-- TABLED, not to be part of 1.0: <xs:attribute name="draggable" default="false" type="boolean"/> -->
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-center">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-right">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="panel-footer">
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="container-dialog" substitutionGroup="AllWidgets">
        <xs:annotation><xs:documentation>
            The contents start out hidden with only a button with the button-text on it. When the button is clicked on
            a dialog opens to show the contents.
        </xs:documentation></xs:annotation>
        <xs:complexType>
            <xs:group ref="widget-elements" minOccurs="0" maxOccurs="unbounded"/>
            <xs:attribute name="id" type="xs:string" use="required"/>
            <xs:attribute name="button-text" type="xs:string" use="required"/>
            <xs:attribute name="width" type="xs:string" default="600"/>
            <xs:attribute name="height" type="xs:string" default="600"/>
        </xs:complexType>
    </xs:element>


    <!-- ================ Includes ================ -->
    <!-- possible good idea, but not implementing in 1.0; should use render-mode.text instead
    <xs:element name="include-content" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="content-path" type="xs:string"/>
            <xs:attribute name="sub-content-key" type="xs:string" use="optional"/>
            <xs:attribute name="xml-escape" default="false" type="boolean"/>
        </xs:complexType>
    </xs:element>
    -->
    <xs:element name="include-screen" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:attribute name="location" type="xs:string" use="required"/>
            <xs:attribute name="share-scope" default="false" type="boolean"/>
        </xs:complexType>
    </xs:element>

    <!-- ============== Tree ============== -->
    <!-- TABLED, not to be part of 1.0:
    <xs:element name="tree" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:sequence>
                <xs:element maxOccurs="unbounded" ref="tree-node"/>
            </xs:sequence>
            <xs:attribute type="xs:string" name="name" use="optional"/>
            <xs:attribute type="xs:string" name="root-node-name" use="required"/>
            <xs:attribute type="xs:string" name="open-depth" default="0"/>
            <xs:attribute type="xs:string" name="entity-name"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="tree-node">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" ref="condition"/>
                <xs:choice minOccurs="0">
                    <xs:element ref="entity-find-one"/>
                    <xs:element ref="service-call"/>
                </xs:choice>
                <xs:element ref="widgets"/>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="tree-sub-node"/>
            </xs:sequence>
            <xs:attribute type="xs:string" name="name" use="required"/>
            <xs:attribute type="xs:string" name="entry-name" />
            <xs:attribute type="xs:string" name="entity-name" />
            <xs:attribute type="xs:string" name="join-field-name" />
        </xs:complexType>
    </xs:element>
    <xs:element name="tree-sub-node">
        <xs:complexType>
            <xs:sequence>
                <xs:choice>
                    <xs:element ref="entity-find"/>
                    <xs:element ref="service-call"/>
                </xs:choice>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="out-field-map"/>
            </xs:sequence>
            <xs:attribute type="xs:string" name="node-name" use="required"/>
        </xs:complexType>
    </xs:element>
    <xs:element name="out-field-map">
        <xs:complexType>
            <xs:attribute type="xs:string" name="field-name" use="required"/>
            <xs:attribute type="xs:string" name="to-field-name"/>
        </xs:complexType>
    </xs:element>
    -->

    <!-- ============== Render Mode Elements =============== -->
    <xs:element name="render-mode" substitutionGroup="AllWidgets">
        <xs:complexType>
            <xs:choice minOccurs="1" maxOccurs="unbounded">
                <xs:element ref="text"/>
                <!-- the gwt and swing elements are just placeholders for now, won't be implemented in this rev -->
                <!-- <xs:element ref="gwt"/> -->
                <!-- <xs:element ref="swing"/> -->
            </xs:choice>
        </xs:complexType>
    </xs:element>
    
    <!-- ============== Text Specific Elements =============== -->
    <xs:element name="text">
        <xs:complexType>
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="type" type="xs:string" default="any">
                        <xs:annotation><xs:documentation>
                            Can be anything. Default supported values include: text, cwiki, html, xsl-fo, xml, and csv.
                            A value of "any" will cause it to be used if no other element matches the current output type.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="location" type="xs:string">
                        <xs:annotation><xs:documentation>
                            Template location can include various prefixes to support including from a file, http, component,
                            or a content repository.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="template" type="boolean" default="true">
                        <xs:annotation><xs:documentation>
                            Interpret the text at the location as an FTL template?
                            Defaults to true, set to false if you want the text included literally.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="encode" default="false" type="boolean">
                        <xs:annotation><xs:documentation>
                            If true text will be encoded so that it does not interfere with markup of the target output.
                            Templates ignore this setting and are never encoded.

                            For example, if output is HTML then data presented will be HTML encoded so that all
                            HTML-specific characters are escaped.
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="no-boundary-comment" type="boolean" default="false">
                        <xs:annotation><xs:documentation>
                            Don't ever put boundary comments before this (for opening ?xml tag, etc).
                        </xs:documentation></xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
    </xs:element>

    <!-- ============== GWT Specific Elements =============== -->
    <xs:element name="GwtWidgets" abstract="true"/>
    <xs:element name="gwt">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="GwtWidgets"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>

    <!-- ============== Swing Specific Elements =============== -->
    <xs:element name="SwingWidgets" abstract="true"/>
    <xs:element name="swing">
        <xs:complexType>
            <xs:sequence>
                <xs:element minOccurs="0" maxOccurs="unbounded" ref="SwingWidgets"/>
            </xs:sequence>
        </xs:complexType>
    </xs:element>
</xs:schema>
